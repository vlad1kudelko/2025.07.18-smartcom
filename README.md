# Тестовое задание

Архитектура микросервиса будет состоять из нескольких ключевых модулей, работающих вместе для достижения требуемой функциональности. Основные компоненты системы:

## Схема БД

1. Таблица servers

```yaml
   - id: уникальный идентификатор сервера
   - hostname: адрес сервера
   - port: порт для SFTP
   - username: имя пользователя для SFTP
   - password: пароль для SFTP
```

2. Таблица files

```yaml
   - id: уникальный идентификатор файла
   - servers_id: внешний ключ на таблицу servers
   - filename: имя файла
   - status: статус обработки (например, "новый", "в процессе", "обработан", "ошибка")
   - timestamp: время создания файла
```

## Модули приложения

1. Модуль мониторинга каталогов
    - Функция мониторинга каталогов с заданным интервалом проверяет sftp сервера на наличие новых файлов
    - В случае наличия новых файлов, создается запись в таблице files (со статусом "новый")

2. Модуль обработки файлов
    - Для всех "новых" файлов создается задача на обработку в воркере Celery, статус меняется на "в процессе"
        - Функция скачивания файла по SFTP
        - Функция загрузки файла в MinIO
        - Функция уведомления внешнего сервиса через AMQP

3. Модуль админки
    - Отображение списка файлов и их статусов
    - Отображение списка серверов (с возможностью добавления/удаления/редактирования)

## Алгоритм работы части, отвечающей за скачивание файлов

1. Запускается функция мониторинга, которая периодически проверяет каталоги на наличие новых файлов.
2. Если найден новый файл:
   - Создается задача скачивания файла и добавляется в очередь Celery.
   - Устанавливается статус файла как "новый" в базе данных.
3. Воркеры Celery:
   - Берут задачи из очереди и обрабатывают их.
   - Сначала скачивают файл по SFTP с использованием информации о сервере.
   - Загружают файл в MinIO и изменяют статус файла на "обработан" в базе данных.
   - Уведомляют внешний сервис через AMQP о том, что файл был успешно загружен.
4. В случае ошибки (например, при скачивании) статус файла устанавливается на "ошибка", и может быть реализована логика повторной попытки.

## Подводные камни

1. Потеря файла: Обязательно нужно реализовать логику обнаружения и обработки ошибок, связанных с потерей файла, либо его недоступностью на сервере.
2. Состояние сети: Неполадки и задержки в соединении могут мешать скачиванию файлов. Необходимо учитывать таймауты и повторные попытки соединения.
3. Необходимость многопоточности: При параллельной обработке нескольких файлов могут возникать конфликты с доступом к одним и тем же ресурсам (например, к БД). Следует использовать блокировки и транзакции.
4. Проблемы с памятью: Обработка крупных файлов может требовать значительных объемов памяти. Необходимо контролировать использование ресурсов и оптимизировать работу с файлами (например, использовать потоковое скачивание).
5. Устойчивость к сбоям: Для повышения надежности сервиса следует тщательно тестировать работу в стрессовых условиях, а также продумать стратегию резервирования данных.

Все эти аспекты следует учитывать на этапе проектирования и разработки, чтобы обеспечить стабильную и надежную работу микросервиса.

## Запуск проекта

Перед запуском всех микросервисов необходимо создать общую docker-сеть, чтобы сервисы могли взаимодействовать друг с другом:

```bash
docker network create smartcom_network
```

### Быстрый запуск всех сервисов

Для удобства вы можете запустить все микросервисы одной командой:

```bash
./run.sh
```

Для остановки всех сервисов используйте:

```bash
./stop.sh
```

### Ручной запуск

Также можно запускать нужные сервисы из соответствующих директорий с помощью:

```bash
docker-compose up -d
```

Это обеспечит корректную работу всех компонентов системы.
